package HAL.GridsAndAgents;

import HAL.Interfaces.*;

import java.io.Serializable;

import static HAL.Util.DispWrap;
import static HAL.Util.Norm;
import static HAL.Util.NormSquared;

/**
 * Agent2DBase functions are shared amongst all 2D agent types
 */
public abstract class Agent2DBase<T extends AgentGrid2D> extends AgentBaseSpatial<T> implements Serializable {

    /**
     * returns the X index of the square that the agent is currently on.
     */
    public abstract int Xsq();

    /**
     * returns the Y index of the square that the agent is currently on.
     */
    public abstract int Ysq();

    /**
     * returns the X coordinate of the agent. If the Agent is on-lattice, these functions will return the
     * coordinates of the middle of the square that the agent is on.
     */
    public abstract double Xpt();

    /**
     * returns the Y coordinate of the agent. If the Agent is on-lattice, these functions will return the
     * coordinates of the middle of the square that the agent is on.
     */
    public abstract double Ypt();

    /**
     * returns the index of the center of the square in otherGrid that the coordinate maps to.
     */
    public int MapXsq(Grid2D other) {
        return (int) (((Xsq() + 0.5) * other.Xdim()) / G.xDim);
    }

    /**
     * returns the index of the center of the square in otherGrid that the coordinate maps to.
     */
    public int MapYsq(Grid2D other) {
        return (int) (((Ysq() + 0.5) * other.Ydim()) / G.yDim);
    }

    /**
     * returns the index of the center of the square in otherGrid that the coordinate maps to.
     */
    public int MapI(Grid2D other) {
        return other.I(MapXsq(other), MapYsq(other));
    }

    /**
     * returns the provided coordinate scaled to the dimensions of the otherGrid.
     */
    public double MapXpt(Grid2D other) {
        return Xpt() * other.Xdim() / G.xDim;
    }

    /**
     * returns the provided coordinate scaled to the dimensions of the otherGrid.
     */
    public double MapYpt(Grid2D other) {
        return Ypt() * other.Ydim() / G.yDim;
    }

    /**
     * This function takes a neighborhood (As generated by the neighborhood Util functions, or using
     * GenHood2D/GenHood3D), translates the neighborhood coordinates to be centered around the agent, and computes the
     * set of indices that the translated coordinates map to. The function returns the number of valid locations it set,
     * which if wraparound is disabled may be less than the full set of coordinate pairs. this means that the passed in
     * ret list will not be completely filled with valid entries. See the CellStep function in the Complete Model
     * example for more information.
     */
    public int MapHood(int[] hood) {
        return G.MapHood(hood, Xsq(), Ysq());
    }

    /**
     * These functions are similar to the the MapHood function, but they will only include valid empty or occupied
     * indices, and skip the others.
     */
    public int MapEmptyHood(int[] hood) {
        return G.MapEmptyHood(hood, Xsq(), Ysq());
    }

    /**
     * These functions are similar to the the MapHood function, but they will only include valid empty or occupied
     * indices, and skip the others.
     */
    public int MapOccupiedHood(int[] hood) {
        return G.MapOccupiedHood(hood, Xsq(), Ysq());
    }

    /**
     * This function takes a neighborhood and another mapping function as argument, the mapping function should return a
     * boolean that specifies whether coordinates map to a valid location. the function will only include valid indices,
     * and skip the others.
     */
    public int MapHood(int[] hood, IndexCoords2DBool Eval) {
        return G.MapHood(hood, Xsq(), Ysq(), Eval);
    }

    /**
     * gets the X displacement from this agent to a given x position
     */
    public double DispX(double x) {
        return G.wrapX ? DispWrap(Xpt(), x, G.xDim) : x-Xpt();
    }

    /**
     * gets the Y displacement from this agent to a given y position
     */
    public double DispY(double y) {
        return G.wrapY ? DispWrap(Ypt(), y, G.yDim) : y-Ypt();
    }

    /**
     * gets the distance from this agent to another position
     */
    public double Dist(double x,double y){
        double dx = DispX(x);
        double dy = DispY(y);
        return Norm(dx, dy);
    }

    /**
     * gets the distance squared from this agent to another position, more efficient than Dist
     */
    public double DistSquared(double x,double y){
        double dx = DispX(x);
        double dy = DispY(y);
        return NormSquared(dx,dy);
    }

}

