package HAL.GridsAndAgents;

import HAL.Interfaces.*;

import java.io.Serializable;

import static HAL.Util.DispWrap;
import static HAL.Util.Norm;
import static HAL.Util.NormSquared;

/**
 * Agent3DBase functions are shared amongst all 3D agent types
 */
public abstract class Agent3DBase<T extends AgentGrid3D> extends AgentBaseSpatial<T> implements Serializable {
    /**
     * returns the X index of the square that the agent is currently on.
     */
    public abstract int Xsq();

    /**
     * returns the Y index of the square that the agent is currently on.
     */
    public abstract int Ysq();

    /**
     * returns the Z index of the square that the agent is currently on.
     */
    public abstract int Zsq();

    /**
     * returns the X coordinate of the agent. If the Agent is on-lattice, these functions will return the coordinates of
     * the middle of the square that the agent is on.
     */
    public abstract double Xpt();

    /**
     * returns the Y coordinate of the agent. If the Agent is on-lattice, these functions will return the coordinates of
     * the middle of the square that the agent is on.
     */
    public abstract double Ypt();

    /**
     * returns the Z coordinate of the agent. If the Agent is on-lattice, these functions will return the coordinates of
     * the middle of the square that the agent is on.
     */
    public abstract double Zpt();

    /**
     * returns the index of the center of the square in otherGrid that the coordinate maps to.
     */
    public int MapXsq(Grid3D other) {
        return (int) (((Xsq() + 0.5) * other.Xdim()) / G.xDim);
    }

    /**
     * returns the index of the center of the square in otherGrid that the coordinate maps to.
     */
    public int MapYsq(Grid3D other) {
        return (int) (((Ysq() + 0.5) * other.Ydim()) / G.yDim);
    }

    /**
     * returns the index of the center of the square in otherGrid that the coordinate maps to.
     */
    public int MapZsq(Grid3D other) {
        return (int) (((Zsq() + 0.5) * other.Zdim()) / G.zDim);
    }

    /**
     * returns the index of the center of the square in otherGrid that the coordinate maps to.
     */
    public int MapI(Grid3D other) {
        return other.I(MapXsq(other), MapYsq(other), MapZsq(other));
    }

    /**
     * returns the provided coordinate scaled to the dimensions of the otherGrid.
     */
    public double MapXpt(Grid3D other) {
        return Xpt() * other.Xdim() / G.xDim;
    }

    /**
     * returns the provided coordinate scaled to the dimensions of the otherGrid.
     */
    public double MapYpt(Grid3D other) {
        return Ypt() * other.Ydim() / G.yDim;
    }

    /**
     * returns the provided coordinate scaled to the dimensions of the otherGrid.
     */
    public double MapZpt(Grid3D other) {
        return Ypt() * other.Zdim() / G.zDim;
    }

    /**
     * This function takes a neighborhood (As generated by the neighborhood Util functions, or using
     * GenHood2D/GenHood3D), translates the neighborhood coordinates to be centered around the agent, and computes the
     * set of indices that the translated coordinates map to. The function returns the number of valid locations it set,
     * which if wraparound is disabled may be less than the full set of coordinate pairs. this means that the passed in
     * ret list will not be completely filled with valid entries. See the CellStep function in the Complete Model
     * example for more information.
     */
    public int MapHood(int[] hood) {
        return G.MapHood(hood, Xsq(), Ysq(), Zsq());
    }

    /**
     * This function takes a neighborhood and another mapping function as argument, the mapping function should return a
     * boolean that specifies whether coordinates map to a valid location. the function will only include valid indices,
     * and skip the others.
     */
    public int MapHood(int[] hood, IndexCoords3DBool Eval) {
        return G.MapHood(hood, Xsq(), Ysq(), Zsq(), Eval);
    }

    /**
     * These functions are similar to the the MapHood function, but they will only include valid empty or occupied
     * indices, and skip the others.
     */
    public int MapEmptyHood(int[] hood) {
        return G.MapEmptyHood(hood, Xsq(), Ysq(), Zsq());
    }


    /**
     * These functions are similar to the the MapHood function, but they will only include valid empty or occupied
     * indices, and skip the others.
     */
    public int MapOccupiedHood(int[] hood) {
        return G.MapOccupiedHood(hood, Xsq(), Ysq(), Zsq());
    }

    /**
     * gets the X displacement from this agent to a given x position
     */
    public double DispX(double x) {
        return G.wrapX ? DispWrap(Xpt(), x, G.xDim) : x-Xpt();
    }

    /**
     * gets the Y displacement from this agent to a given y position
     */
    public double DispY(double y) {
        return G.wrapY ? DispWrap(Ypt(), y, G.yDim) : y-Ypt();
    }

    /**
     * gets the Z displacement from this agent to a given z position
     */
    public double DispZ(double z) {
        return G.wrapZ ? DispWrap(Zpt(), z, G.zDim) : z-Zpt();
    }

    /**
     * gets the distance from this agent to another position
     */
    public double Dist(double x,double y,double z){
        double dx = DispX(x);
        double dy = DispY(y);
        double dz = DispY(z);
        return Norm(dx, dy,dz);
    }

    /**
     * gets the distance squared from this agent to another position, more efficient than Dist
     */
    public double DistSquared(double x,double y,double z){
        double dx = DispX(x);
        double dy = DispY(y);
        double dz = DispZ(z);
        return NormSquared(dx,dy,dz);
    }
}
