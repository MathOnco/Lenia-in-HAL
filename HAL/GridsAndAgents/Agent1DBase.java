package HAL.GridsAndAgents;

import HAL.Interfaces.Coords1DBool;
import HAL.Interfaces.Grid1D;

import java.io.Serializable;

import static HAL.Util.DispWrap;
import static HAL.Util.Norm;

/**
 * Agent1DBase functions are shared amongst all 1D agent types
 */
public abstract class Agent1DBase<T extends AgentGrid1D> extends AgentBaseSpatial<T> implements Serializable {
    /**
     * returns the X index of the square that the agent is currently on.
     */
    public abstract int Xsq();

    /**
     * returns the X coordinate of the agent. If the Agent is on-lattice, these functions will return the coordinates of
     * the middle of the square that the agent is on.
     */
    public abstract double Xpt();

    /**
     * returns the index of the center of the square in otherGrid that the coordinate maps to.
     */
    public int MapXsq(Grid1D other) {
        return (int) (((Xsq() + 0.5) * other.Xdim()) / G.xDim);
    }

    /**
     * returns the index of the center of the square in otherGrid that the coordinate maps to.
     */
    public int MapI(Grid1D other) {
        return MapXsq(other);
    }

    /**
     * returns the provided coordinate scaled to the dimensions of the otherGrid.
     */
    public double MapXpt(Grid1D other) {
        return Xpt() * other.Xdim() / G.xDim;
    }


    /**
     * This function takes a neighborhood (As generated by the neighborhood Util functions, or using
     * GenHood2D/GenHood3D), translates the neighborhood coordinates to be centered around the agent, and computes the
     * set of indices that the translated coordinates map to. The function returns the number of valid locations it set,
     * which if wraparound is disabled may be less than the full set of coordinate pairs. this means that the passed in
     * ret list will not be completely filled with valid entries. See the CellStep function in the Complete Model
     * example for more information.
     */
    public int MapHood(int[] hood) {
        return G.MapHood(hood, Xsq());
    }


    /**
     * These functions are similar to the the MapHood function, but they will only include valid empty or occupied
     * indices, and skip the others.
     */
    public int MapEmptyHood(int[] hood) {
        return G.MapEmptyHood(hood, Xsq());
    }

    /**
     * These functions are similar to the the MapHood function, but they will only include valid empty or occupied
     * indices, and skip the others.
     */
    public int MapOccupiedHood(int[] hood) {
        return G.MapOccupiedHood(hood, Xsq());
    }

    /**
     * This function takes a neighborhood and another mapping function as argument, the mapping function should return a
     * boolean that specifies whether coordinates map to a valid location. the function will only include valid indices,
     * and skip the others.
     */
    public int MapHood(int[] hood, Coords1DBool Eval) {
        return G.MapHood(hood, Xsq(), Eval);
    }


    /**
     * gets the X displacement from this agent to a given x position
     */
    public double DispX(double x) {
        return G.wrapX ? DispWrap(Xpt(), x, G.xDim) : x-Xpt();
    }

    /**
     * gets the distance from this agent to another position
     */
    public double Dist(double x){
        return Math.abs(DispX(x));
    }

    /**
     * gets the distance squared from this agent to another position, included for completeness
     */
    public double DistSquared(double x){
        double disp=DispX(x);
        return disp*disp;
    }
}
